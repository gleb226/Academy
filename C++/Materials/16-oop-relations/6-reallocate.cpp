
// Функція reallocate() змінює розмір масиву. Всі існуючі елементи всередині масиву будуть знищені. Процес швидкий
void reallocate(int newLength)
{
    // Видаляємо всі існуючі елементи всередині масиву
    erase();

    // Якщо наш масив повинен бути пустим, то виконуємо повернення тут
    if (newLength <= 0)
        return;

    // Далі нам потрібно виділити нові елементи
    m_data = new int[newLength];
    m_length = newLength;
}

// Функція resize() змінює розмір масиву. Всі існуючі елементи зберігаються. Процес повільний
void resize(int newLength)
{
    // Якщо масив вже потрібної довжини, то виконуємо return
    if (newLength == m_length)
        return;

    // Якщо потрібно зробити масив пустим, то робимо це і потім виконуємо return
    if (newLength <= 0)
    {
        erase();
        return;
    }

    // Тепер припустимо, що newLength складається, принаймні, з одного елементу. Виконується наступний алгоритм дій:
    // 1. Виділяємо новий масив.
    // 2. Копіюємо елементи з існуючого масиву в наш щойно виділений масив.
    // 3. Знищуємо старий масив і даємо команду m_data вказувати на новий масив.

    // Виділяємо новий масив.
    int* data = new int[newLength];

    // Потім нам потрібно розібратися з кількістю скопійованих елементів в новий масив.
    // Нам потрібно скопіювати стільки елементів, скільки їх є в меншому з масивів
    if (m_length > 0)
    {
        int elementsToCopy = (newLength > m_length) ? m_length : newLength;

        // Почергово копіюємо елементи
        for (int index = 0; index < elementsToCopy; ++index)
            data[index] = m_data[index];
    }

    // Видаляємо старий масив, тому що він нам вже не потрібний
    delete[] m_data;

    // І використовуємо замість старого масиву новий! Зверніть увагу, m_data вказує на ту ж адресу, на яку вказує наш новий динамічно виділений масив.
    // Оскільки дані були динамічно виділені, то вони не будуть знищені, коли вийдуть з області видимості
    m_data = data;
    m_length = newLength;
}