// Синтаксис оголошення шаблонного аргументу-константи виглядає дуже схожим
// на синтаксис оголошення аргументів-типів. Замість ключового слова "typename"
// записується тип, який має константа. У даному випадку, задамо число від
// якого рахується факторіал типом "int", а аргумент назвемо "Value".
// Після оголошення аргументу можна використовувати його в тілі шаблону функції як
// звичайну константу.
template<int Value>
int getFactorial()
{
    // Ми вважаємо факторіал рекурсивним викликом _іншої шаблонної функції_,
    // одержуваної _з цього ж шаблону функції_ передачею в якості
    // значення шаблонного аргументу значення "Value - 1". Тобто з виклику
    // "getFactorial<4>()" буде викликатися "getFactorial<3>()", з нього -
    // "getFactorial<2>()" і т.д.
    // Нижче, в "main()", детально розбирається, як працюватиме цей шаблон
    // функції.
    return Value * getFactorial<Value - 1>();
}

// Спеціалізації можливо використовувати з шаблонними аргументами-константами
// так само, як з аргументами-типами. У цьому випадку ми описуємо
// спеціалізацію шаблону "template<int Value> int getFactorial()" за значенням
// шаблонного аргументу "Value", умова вибору спеціалізації - рівність
// значення шаблонного аргументу числу "1". Значення, за яким буде
// вибиратися спеціалізація записується так само, як це робилося для
// спеціалізацій за типами, з тією різницею, що для аргументів-констант ми пишемо,
// власне, значення константи.
template<>
int getFactorial<1>()
{
    return 1;
}

int main()
{
    // Щоб зрозуміти, як працює ця реалізація факторіалу, розглянемо, як
    // компілятор виконує цей виклик.
    //
    // 1. Зустрівши запис getFactorial<4>() компілятор звернеться до опису
    // шаблону функції "template<int Value> int getFactorial()". У шаблону є
    // одна спеціалізація - щодо рівності значення аргументу Value одиниці:
    // "template<> int getFactorial<1>()". У виклик передано значення 4, отже
    // спеціалізація не підходить і компілятор вибере узагальнену версію шаблону.
    // У породженій шаблонній функції "getFactorial<4>()" викликається
    // "getFactorial<Value - 1>()", тобто "getFactorial<3>()"
    //
    // 2. З "getFactorial<3>()" все буде аналогічно до пункту 1. Спеціалізація щодо
    // рівності Value одиниці не підійде, породжена функція
    // "getFactorial<3>()" міститиме виклик "getFactorial<2>()".
    //
    // 3. Для "getFactorial<2>()" спеціалізація за рівністю "Value" одиниці
    // також не підходить. Породжена функція "getFactorial<2>()" буде містити в
    // в реалізації виклик "getFactorial<1>()"... І ось тут, нарешті, буде
    // обрано спеціалізацію "template<> int getFactorial<1>()", яка поверне
    // константу "1". З цього місця почнеться повернення з "рекурсивного" виклику.
    //
    // Слово "рекурсивний" записано в лапках, тому що тут ми маємо справу з
    // незвичною рекурсією. Функція "getFactorial<4>()" викликає функцію
    // "getFactorial<3>()", та викликає "getFactorial<2>()" і та, нарешті,
    // викликає "getFactorial<1>()"... і всі чотири ці функції породжені з
    // "template<int Value> int getFactorial()" - це різні функції. Як у
    // минулих прикладах зі спеціалізаціями за типами, з шаблонів функцій з
    // аргументами-константами будуть виходити різні шаблонні функції
    // підстановкою різних констант.
    const int factorial4Result = getFactorial<4>();

    return 0;
}

