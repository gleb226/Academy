### Домашнє завдання: реалізація власних версій популярних алгоритмів STL у C++

**Мета завдання:**  
Розвинути розуміння внутрішньої роботи стандартних алгоритмів C++ з бібліотеки STL (Standard Template Library), покращити навички роботи з шаблонами (templates), ітераторами та контейнерами. Ви повинні реалізувати власні версії алгоритмів, не використовуючи вбудовані функції з `<algorithm>` або інших STL-заголовків для основної логіки (допускається використання контейнерів як `std::vector` для тестування).

**Завдання:**  
Створіть шаблонні функції (template functions), які імітують поведінку популярних алгоритмів STL. Кожна функція повинна працювати з будь-якими ітерабельними контейнерами (наприклад, `std::vector`, `std::list`, `std::array`) через ітератори. Використовуйте шаблони для узагальнення типів даних.

Реалізуйте наступні алгоритми (виберіть щонайменше 4 з наведеного списку):

1. **my_for_each** (аналог `std::for_each`):

    - Приймає діапазон ітераторів (початок і кінець) та унарну функцію (або лямбду).
    - Застосовує функцію до кожного елемента в діапазоні.
    - Повертає void.
    - Приклад використання: `my_for_each(vec.begin(), vec.end(), [](int& x) { x *= 2; });`.

2. **my_transform** (аналог `std::transform`, подібний до map):

    - Приймає вхідний діапазон ітераторів, вихідний ітератор та унарну функцію.
    - Застосовує функцію до кожного елемента вхідного діапазону та записує результат у вихідний.
    - Повертає ітератор на кінець вихідного діапазону.
    - Приклад: `my_transform(vec.begin(), vec.end(), out.begin(), [](int x) { return x + 1; });`.

3. **my_copy_if** (аналог `std::copy_if`, для фільтрації):

    - Приймає вхідний діапазон ітераторів, вихідний ітератор та предикат (умову).
    - Копіює елементи, для яких предикат повертає true, у вихідний діапазон.
    - Повертає ітератор на кінець вихідного діапазону.
    - Приклад: `my_copy_if(vec.begin(), vec.end(), out.begin(), [](int x) { return x > 0; });`.

4. **my_find_if** (аналог `std::find_if`):

    - Приймає діапазон ітераторів та предикат.
    - Повертає ітератор на перший елемент, для якого предикат true, або end() якщо не знайдено.
    - Приклад: `auto it = my_find_if(vec.begin(), vec.end(), [](int x) { return x % 2 == 0; });`.

5. **my_accumulate** (аналог `std::accumulate`):

    - Приймає діапазон ітераторів, початкове значення та бінарну операцію (за замовчуванням додавання).
    - Накопичує результат операції над елементами.
    - Повертає накопичене значення.
    - Приклад: `int sum = my_accumulate(vec.begin(), vec.end(), 0, std::plus<int>());`.

6. **my_remove_if** (аналог `std::remove_if`):
    - Приймає діапазон ітераторів та предикат.
    - "Видаляє" елементи, для яких предикат true (зсуває інші елементи вперед).
    - Повертає ітератор на новий кінець діапазону.
    - Приклад: `auto new_end = my_remove_if(vec.begin(), vec.end(), [](int x) { return x < 0; }); vec.erase(new_end, vec.end());`.

**Вимоги до реалізації:**

-   Використовуйте шаблони для підтримки будь-яких типів даних (наприклад, `template <typename Iterator, typename Func>`).
-   Обробляйте крайні випадки: порожній діапазон, один елемент, елементи, що не задовольняють умову.
-   Не використовуйте вбудовані STL-алгоритми в реалізації (наприклад, не викликайте `std::for_each` всередині вашої функції).
-   Додайте коментарі до коду, пояснюючи логіку.
-   Створіть тестовий код у функції `main()`:
    -   Створіть контейнер (наприклад, `std::vector<int>`) з даними.
    -   Викличте ваші функції та виведіть результати (використовуйте `std::cout`).
    -   Перевірте коректність за допомогою assert або ручного виведення.

**Додаткові бонуси (необов'язково):**

-   Додайте підтримку для асоціативних контейнерів (наприклад, `std::map`).
-   Напишіть юніт-тести за допомогою простої бібліотеки, як Google Test (якщо доступно), або ручних перевірок.
